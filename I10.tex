% This is the ADASS_template.tex LaTeX file, 26th August 2016.
% It is based on the ASP general author template file, but modified to reflect the specific
% requirements of the ADASS proceedings.
% Copyright 2014, Astronomical Society of the Pacific Conference Series
% Revision:  14 August 2014

% To compile, at the command line positioned at this folder, type:
% latex ADASS_template
% latex ADASS_template
% dvipdfm ADASS_template
% This will create a file called aspauthor.pdf.}

\documentclass[11pt,twoside]{article}

% Do NOT use ANY packages other than asp2014. 
\usepackage{asp2014}
\usepackage{eurosym}
\aspSuppressVolSlug
\resetcounters

% References must all use BibTeX entries in a .bibfile.
% References must be cited in the text using \citet{} or \citep{}.
% Do not use \cite{}.
% See ManuscriptInstructions.pdf for more details
\bibliographystyle{asp2014}

% The ``markboth'' line sets up the running heads for the paper.
% 1 author: "Surname"
% 2 authors: "Surname1 and Surname2"
% 3 authors: "Surname1, Surname2, and Surname3"
% >3 authors: "Surname1 et al."
% Replace ``Short Title'' with the actual paper title, shortened if necessary.
% Use mixed case type for the shortened title
% Ensure shortened title does not cause an overfull hbox LaTeX error
% See ASPmanual2010.pdf 2.1.4  and ManuscriptInstructions.pdf for more details
\markboth{Rees}{Quality software: what does it mean?}

\begin{document}

\title{Quality software: what does it mean?}

% Note the position of the comma between the author name and the 
% affiliation number.
% Author names should be separated by commas.
% The final author should be preceded by "and".
% Affiliations should not be repeated across multiple \affil commands. If several
% authors share an affiliation this should be in a single \affil which can then
% be referenced for several author names.
% See ManuscriptInstructions.pdf and ASPmanual2010.pdf 3.1.4 for more details
\author{Nick Rees,$^1$
\affil{$^1$SKA Organization, Macclesfield, Cheshire, United Kingdom; 	\email{n.rees@skatelescope.org}}
}

% This section is for ADS Processing.  There must be one line per author.
\paperauthor{Nick Rees}{n.rees@skatelesscope.org}{}{SKA Organization}{Computing and Software}{Macclesfield}{Cheshire}{SK11 9DL}{United Kingdom}

\begin{abstract}
The SKA is a major international project which will generate transformational science in the realm of metre and centimetre astronomy. It can be described as a \emph{software telescope}, with RF signals being digitized directly and generating aggregated data rates of up to ~1.7 Petabits/sec from the antennas, and intermediate data rates in the signal chain of ~5 Terabits/sec. The telescope is being designed by 10 pre-construction consortia with input from around 250 institutes world-wide and will enter the construction phase in 2019. The consortia are estimating that the computing software and hardware construction costs are both in the \euro80-90M range. 

Many of these numbers are unprecedented in astronomy and this has led to much soul searching. In 2016 the SKA Organization, which coordinates the design consortia, has used software quality, in all its forms, as a way of rationalizing key design decisions and defining primary project processes. Whilst most of this could be seen as being based on best practices elsewhere in the software industry, it has brought a number of fresh perspectives that have not been actively explored in many astronomy projects. The author will present some of these perspectives and how they, along with project risk, are seen as the primary drivers of the software processes and design.
\end{abstract}

\section{Introduction and Warning} % (fold)
\label{sec:introduction_and_warning}

I have decided to write this paper in first-person rather than third person because it reflects a personal journey over 18 months rather than reporting anything that is new and ground-breaking. What I have to say may be well understood by other communities but I don't believe it is understood by many in the astronomical software community and it is helpful to review many of the factors that affect software quality in one place. This paper also reflects a view of the top-level status of SKA software development at this point in time and this, in itself, has merit.

\subsection{What is the problem?} % (fold)
\label{sub:what_is_the_problem}
The senior management of large projects often comprise people who have minimal software management experience. The systems they understand typically have limited modifiability requirements after the construction period has completed, and are amenable to a simple hierarchical breakdown. 

Consequently, the processes they are familiar with don't emphasise the modifiability or structural complexity which software often has. There is nothing wrong with this per se, but it does provide a barrier that software managers have to overcome. We may compound the problem by failing to communicate in a language that our managers understand, or our ideas may be poorly formed -- we know a process is far from ideal, but aren'table to convincingly describe a process which is demonstrably better.

I encountered a similar situation when I arrived at the SKA Organisation.I was the only person who had a high level mandate to think specifically about software across the system. There was a large emphasis on documentation-based earned value milestones, and in some areas of software individuals were working on documentation that they knew was irrelevant because of recent design changes. However, these documents still had to be completed to meet some earned-value milestone. In fact, whilst I never posed it in this way, I am sure if I asked somepeople where what they were doing related to the Agile Manifesto \citep{agile}, they would have concluded they were on the wrong side of each of the four manifesto value statements. This was so entrenched that you could argue we are still in this position in many areas, but I now believe there is some light at the end of the tunnel.
% subsection what_is_the_problem (end)

\subsection{How did we get here?} % (fold)
\label{sub:how_did_we_get_here}
When I look back at the management of large ground-based astronomy projects I feel 
that a pivotal time was in the late 1980's and early 1990's when the first 8-10 metre 
class optical telescopes were built. Instruments transitioned from systems that could be 
built by a small university group to systems that needed large teams to develop them. 
Unfortunately, the existing processes didn't scale well so there were a number of high-profile 
failures and development processes had to be updated to be better suited to the 
larger systems. 


Since then, there has been a revolution in software development methods that has 
led to commercial companies, such as Google, Amazon and the like, being able to consistently
build huge software systems that are continually evolving whilst still maintaining 
a high level of quality. The astronomical software community has been aware 
of this but we often find we are working in projects that seem to inherit processes and 
methods that feel more 1980's than modern day. Having encountered this at the SKA, 
this paper is about how we have tried to overcome these problems and build a set of 
software development processes that will be better suited to our core goals. 
% subsection how_did_we_get_here (end)

% section introduction_and_warning (end)


\section{First Steps} % (fold)
\label{sec:first_steps}
When I arrived at the SKA I spent some time trying to understand what the most important 
aspect of my role was to be. I had more responsibility than I had in my previous 
roles and I needed some way to bring all the pieces of the puzzle together. My conclusion was 
that my main focus should be on software quality. At the time I didn't really 
understand where this journey was going to take me, but I felt it was a reasonable place 
to start. I commenced by writing down a few fundamental truths and socialising them 
around the SKA community. This is the \emph{``Fundamental SKA Software and Hardware 
Definition Language Standard''} and it covers things like: 

\begin{itemize}
\item Software must have a license.
\item If the software comes off the shelf, we have to have it on a register, it has to meet our needs and we have to understand how we will support it during its lifecycle -- which could be the 50 year life of the SKA telescopes.
\item If the software is developed by the SKA
	\begin{itemize}
	\item The development must follow a process
	\item The process should ensure that the code is reviewed and tested.
	\item The dependencies should be understood.
	\item etc.
	\end{itemize}
\end{itemize}

After some time I realised that this whilst necessary, is not sufficient. At one point I called this \emph{tactical} 
quality -- meaning that it reflects the day to day concerns of the developer, which is separate from a 
\emph{strategic} quality, which is the quality that is perceived by the user throughout the software's operational 
lifetime. 

% section first_steps (end)

\section{Software Architecture} % (fold)
\label{sec:software_architecture}
To understand quality, you need to know what it is. If you ask a software user they can easily describe it by the 
inverse of some of their experiences - words such as inflexible, fragile, overly complicated, difficult to 
understand, unpredictable and slow spring to mind. More seriously, the International Standards Organisation have 
written a standard on it where it describes quality in terms of \emph{quality in use} model and a \emph{product quality} 
model \citep[see][]{iso25010}. 

\articlefigure{QualityInUse.eps}{i10_fig1}{ISO 25010 Quality in Use model.}

\articlefigure{ProductQuality.eps}{i10_fig2}{ISO 25010 Product Quality model.}

Looking at these (Figure~\ref{i10_fig1} and Figure~\ref{i10_fig2}) it becomes immediately clear that many these 
qualities are a class of requirements that are often called \emph{non-functional}. This means that they often avoided 
because they are too difficult -- they are difficult 
to measure, and they are difficult to isolate as independent quantities. We have found 
that traditional system engineering struggles with these holistic, almost aspirational, 
concepts. 

However, they are important, and if you Google them in the context of software 
development you come across statements like:

\begin{itemize}
	\item \emph{Design for maintainability from the outset.}
	\item \emph{Software has to be designed from the ground up to be secure.}
	\item \emph{Reliability engineering is weaved into the total development cycle.}
\end{itemize}

After considering this it becomes clear that quality is fundamentally related to 
the architecture of your software system. In understanding thisI am indebted to Peter 
Braam, the original architect of the Lustre file system that manyof us have used, and 
who now occasionally hangs out with the SKA Science Data Processing consortium. 
Peter pointed me to the \emph{``Views and Beyond''} software architecture approach developed 
bythe Software Engineering Institute (SEI) at Carnegie Mellon University~\citep{VandB}. This highlights the importance of qualities and we have since developed all our 
software architecture using this approach. 

Aconsequence of the emphasis on quality is the functional requirements that dominate 
many projects are reduced in significance because they have limited effect on 
the software architecture. The focus is more on the qualities the system should have, 
the few key functional requirements and any business factors that are important (these 
might show up as constraints). 

The realisation that requirements are less important than you might think is, I 
think, truly revelational. However, maybe it should be obvious. A key quality of 
software is its modifiability. This differentiates it from most mechanical systems, and 
should make us think about software in terms of its lifecycle. The requirements the software will have to meet in 10 years time will not be the same as they are now. Typically, 
the requirements when a project starts are not the same as when it finishes. Qualities 
of good software are more fixed than the requirements, so you have to think about the 
qualities first.

The SEI gives us a way to develop and understand these qualities. They call them 
quality attributes, and they describe them in terms of use cases called quality attribute 
scenarios. These are use cases which are intended to highlight qualities in a descriptive, 
but measurable way. For example: 

\begin{itemize}
	\item An engineer would like to plot one year of data from a specific attribute for each 
of 200 telescopes within 30 seconds (i.e. performance).
	\item Agroupof scientistswouldlikeanew observing modetobe implementedin2 
months (i.e. modifiability). 
	\item The software teamwantsto upgradetoanewversionoftheOSin1month (i.e. 
modifiability). 
	\item The operatorwantsto diagnosethe system causingthe rootofa cascadefailure 
within1minute (i.e. usability). 
	\item The system is returned to normal service after a server failure within 1 minute 
(i.e. reliability). 
	\item A single failure of a core network component has no discernable effect (i.e. reliability). 
	\item A developer wants to know if she has \emph{broken the build} within 30 minutes of 
commit (i.e. testability).
	\item A developer wants to roll out a modified component to the live system, test it 
and the then revert back to the previous version. Rollout and reversion should be 
quick (less than 5 minutes) and have no impact on observations taking place on 
the rest of the system (i.e. testability). 
\end{itemize}

Itis important to distinguish these from traditional requirements because they are a 
trade-off space that can be prioritised and modified during the architecture development. 
The SEI describes a set of processes you can use to work with them. You can get your 
stakeholders together and brainstorm a list of them. Once you have a list you can vote 
on them, and generate a prioritised list. You can then use this ordering to start thinking 
about decomposing your architecture into well understood architectural patterns or 
choosing even specific frameworks that encapsulate these patterns effectively. If a quality 
isn't all-encompassing you might instead need to use a tactic to address a specific 
quality attribute scenario (see Clements et al.(2001), Bass et al.(2012), Cervantes& 
Kazman(2016)). 

Another feature of software is that it is not amenable to a simple hierarchical decomposition. 
There is a great paper about this by Mark Maier(Maier(2006)). System 
engineers love breaking down a system hierarchically and assigning requirements and 
functions to the parts. However, software doesn't work that way. It has multiple equivalent 
hierarchies. It has layers where one product appears in all products above it in 
the hierarchy. It has functions that can only be fulfilled by multiple products working 
co-operatively. And it all has to be easy to modify and done in the fewest possible lines 
of code. Developing the Software Architecture must address this -- the same software 
must be represented by many views and what may seem simple once the architecture is 
known is not simple at the time. 

One last thought about this. The functional requirements we traditionally focus on 
also cloud our judgement on the types of staff 
we populate our teams with. Deeper 
thinking about what software qualities you really need, such as usability and even pleasure, 
may change the mix of staff you think is best for your project. 
% section software_architecture (end)

\section{Process Quality} % (fold)
\label{sec:process_quality}
The area I have turned to most recently is process quality. If you don't have good 
processes, you can't consistently produce good software. This also harks back to the 
problem I mentioned at the beginning of this proceeding where we seem to be caught in this 
1990's process bubble. For example, the SKA has been constrained by an early decision 
to define the pre-construction work breakdown structure. This was done for good reasons,
but I keep coming back to Conways Law: \emph{``organizations which design systems \hellip 
are constrained to produce designs which are copies of the communication structures 
of these organizations''}~\citep{conway1968}. Lots of people know about this, and it was 
popularised by Fred Brooks in the \emph{``Mythical Man Month''}~\citep{brooks1995}. Conway also 
points out that if the organisation is formed to create the system then the organization 
chart will reflect the first system design, which is almost certainly not the right one. 
This is exactly what happened at the SKA.

However, the most interesting thing I think about Conway's paper is not the law, 
but his conclusion, two paragraphs later: \emph{``Ways must be found to reward design managers for keeping 
their organizations lean and flexible. There is need for a philosophy 
of system design management which is not based on the assumption that adding manpower [sic] simply adds to productivity.''}
This is they key to good processes. 

The quality of your processes should also be matched to the qualities of the system 
you want to build. Software that is very well defined, with no need for modifiability or 
flexibility -- possibly a device driver sandwiched between some existing hardware and 
an operating system API -- may not need flexible development processes, and could 
well be best done by a defined deliverable fixed price, phase-gated contract. 

However, software which, for example, needs high modifiability, high usability, or 
has poorly understood requirements is best developed with a process that matches these 
qualities -- which is where agile processes and agile contracting come in. I am not a 
complete agile convert, but in the scientific domain where flexibility and uncertainty 
are key assets, agile processes seem to be a good match. 

Agile processes are best understood in terms of small teams, but there are a number 
of large scale agile processes available including:

\begin{itemize}
	\item Disciplined Agile Delivery (DAD) 
	\item Dynamic Systems Development Method (DSDM) 
	\item Large Scale Scrum (LeSS) 
	\item Modular Framework for Scaling Scrum 
	\item Scaled Agile Framework (SAFe) 
\end{itemize}

At the SKA we did some research (see, for example Hayes et al. (2016) and APM 
(2017)) and decided to base our software processes on the Scaled Agile Framework 
(Leffingwell, Dean et al. 2017). While the purists may argue that this isn't a fully agile 
framework, it has a clear area where system engineering fits in -- because that domain 
has contributed enormously to our ability to build large, multi-disciplinary systems. 
System engineering is not a substitute for good architecture, it more acts as grease and 
support structure for it, but when used in an agile context it has to adapt (Santander-Vela,
J.2018). This choice was made relatively recently, but has largely been welcomed 
by the SKA community and we are actively working on developing our plans to integrate 
it with the context of the larger construction project. 

% section process_quality (end)

\section{Conclusions} % (fold)
\label{sec:conclusions}
In developing large software systems for astronomy quality is of paramount importance. 
Good software architecture is critical and it is driven more by qualities than most 
functional requirements. Software processes need to match these software qualities and 
whilst software processes have developed enormously in the past 20 years an organisation 
must make a conscious choice what is best for their situation. For most projects the 
agile manifesto is a good anchor point, but you must always remember that the values 
on the right are still important, particularly for large systems. 

I have found that consciously searching out international standards and other examples 
of best practice has provided me with solid foundations, aiding communication 
amongst stakeholders by creating a common language and providing valuable support 
when trying to convince others of the merits of a particular choice. So, whilst software 
often finds itself as the poorly understood sibling of other engineering disciplines I believe 
that upper management can be convinced about software best practices. We also 
have to be conscious of the enormous contributions the other disciplines provide and 
find practices that clearly work with them as well. We need those other disciplines and 
so we must acknowledge and cultivate them. 

% section conclusions (end)


\bibliography{I10}  % For BibTex

\end{document}
